# ShortenUrl 개발기

## 주요목표

- 원문을 유추할 수 없어야 함 (해시값을 이용하기로 함)
- 충돌 시 전략 : 새 url 정보로 갱신(사실상 충돌 고려하지 않고 바로 insert)
- 일주일 간 유효하고 만료되어야 함
- (Advanced) 캐싱 (맵 구현체를 활용해보자) - 완료
- (Advanced) 트래픽 공격에 대한 대비 (큐를 활용해서 구현해보자) - 이건 네트워크에서 처리하는게 맞는 듯
- (Advanced) 유효기간이 만료된 건 어떻게 제거할까? - 완료
- (Advanced) 불법 사이트로 이동되는지 체크하여 방지 - 이것도 네트워크 레벨에서

## 특이사항들

1. `Objects.hash()`와 `Object.hashCode()`는 진짜 hash가 아니다
    - 산사태효과(쇄도효과) 없음
2. 해시값을 Base62로 인코딩해야 할까?
    - 해시를 거치면 이미 원문을 추정하기 어려운 상태이다.
    - Base62 인코딩은 똑같은 값을 다르게 표현하는 결과를 얻을 뿐이다.
        - 다르게 표현해서 얻는 이점이 없다.
        - 오히려 '소문자+숫자' 조합인 해시값이 '소문자+대문자+숫자' 조합의 인코딩값이 되어서, `I(대문자 아이)`, `l(소문자 엘)`, `1(숫자 1)` 등 알아보기 헷갈린 값만 생길 뿐이다
            - 단축 url은 복사-붙여넣기가 아니라 사용자가 기억해서 직접 작성하는 식의 사용도 충분히 고려해야 하기 때문에, 이건 꽤 중요한 문제다.
            - 그게 헷갈리지 않아도, `aBC`라는 문자열이 있을때 사용자는 `에이-비-씨`라고 외우기 때문에, 다시 적을때 소문자인지 대문자인지까지 떠올려야 하는 문제 또한 꽤 헷갈리고 불편한 지점이다.
3. Message digest 알고리즘 선택
    - 결과적으로 `SHA-1`을 택했다.
        - `md5`는 스마트폰을 가지고도 몇 초 안에 충돌이 일어나는 수준이므로 사용이 어렵다고 판단했다.
        - 미국 NIST의 권고를 따라 `SHA-2`를 써야하는가?
            - 성능 차이가 너무 크다: 테스트 결과 2배 이상의 차이가 남.
                - 저사양 컴퓨팅에서는 더욱 큰 차이가 날 것이다.

## 아주 아주 작은 것들...
- 어감의 차이: `find`와 `search`
    - 둘 다 무언가를 찾으나...
        - find : 가지고 있는 한정 자원 또는 대상이 명확한 자원 또는 단일 자원 등을 대상으로 찾음.
        - search : 한정되지 않고 다양한 자원에서 무언가를 찾음.
- 유효기간 만료, 어떻게 검사할까?
    - 첫째: 유효 행위를 시도할 때, 등록일시를 기준으로 application에서 유효기간을 계산하고, 유효한지 검사
        - 매 건이 일괄적인 유효기간을 가질 경우 어플리케이션에서 처리하면 편리할듯.
    - 둘째: 처음 등록할 때 '현재+유효기간'을 계산하여 유효일시 필드로 저장해둠. 유효 행위를 시도할 때는 저장되어있는 유효일시를 조회하여 유효 여부를 검사.
        - 각 건의 유효기간이 상이할 수 있다면 이 방법을 골라야 할듯.
    - 두번째 방법으로 하되, 기본값을 두자.
        - 모든 건이 일괄적인 유효기간을 가지고 있지만, 첫번째 방법으로 하기에는 너무 긴 유효기간(일주일)을 가지고 있다고 생각이 든다.
        - 두 방법이 서로 차이는 있지만, 크게 장단이 나뉘는 선택은 아니라는 생각이 든다.
        - 하지만, 두 번째 방법에는 한 가지 옵션이 더 있기 때문에 이를 선택한다.
- PathVariable을 DTO로 받고 싶으면서...
    - presentation-service 간 사용되는 DTO는 역참조가 생기지 않도록 service에서 가지고 있게끔 했었다.
    - 그런데 컨트롤러 안에서만 사용될 파라미터가 생겼다. (RedirectController#redirectOriginalUrlFromShortenUrl(shortenPath:String))
    - 이 타입도 service가 질 책임인가?
        - 패키지 분리 관점의 생각 : presentation에서만 사용하는 요소인데 왜 service에 둬? presentation이 스스로 책임지면 되지.
        - 유즈케이스 관점의 생각 : 사용자가 보내는 값은, 결국 특정 business scenario가 필요로 하는 값이잖아. 그니까 service에 종속되는 내용이지.
    - 결국 공통모델(common.model)이라는 개념으로 분리했다.
        - 프레젠테이션-서비스 간 결합도는 낮아짐/각 계층과 공통과의 결합도는 높아짐(정말 뽑을만한 것만 뽑았기 때문에 높아져도 별 상관은 없다).
        - 애초에 고민하던 해결방법과는 차이가 있지만, 어쨌든 책임을 적절히 옮겼다는 생각은 듦.
        - 하지만 생각지 못했던 단점도 보인다: 어디서나 공통으로 쓰이는 타입이기 때문에, 타입만 봤을 때 사용목적이 유추되지가 않음(예: '단축할Url요청' =(수정)=> 'Url', 수정 후의 타입은 자신이 어떤 목적을 가지고 있는지 스스로를 충분히 설명하지 않는다)